(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{337:function(t,_,a){"use strict";a.r(_);var v=a(8),e=Object(v.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"_1-面向对象特性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-面向对象特性"}},[t._v("#")]),t._v(" 1.面向对象特性")]),t._v(" "),_("blockquote",[_("p",[t._v("面向对象三大特性：封装、继承、多态")])]),t._v(" "),_("h3",{attrs:{id:"_1-1-封装"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-封装"}},[t._v("#")]),t._v(" 1.1.封装")]),t._v(" "),_("blockquote",[_("p",[t._v("类的属性和方法可以描述一类事物可以做的操作。封装就是把同一类的事物的共性抽取到同一个类中，更加方便使用。封装也叫信息隐藏，数据被保护在抽象数据的内部，尽可能的隐藏细节。用户可以根据对象名和参数访问该对象。封装的好处就是可以实现专业的分工，将实现某一特定功能的代码封装成一个实体后，各个程序员可以在需要的时候调用。还可以隐藏信息，实现细节。通过访问控制权限将不想让用户看见的信息封装起来。")])]),t._v(" "),_("h3",{attrs:{id:"_1-2-继承"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-继承"}},[t._v("#")]),t._v(" 1.2.继承")]),t._v(" "),_("blockquote",[_("p",[t._v("继承就是个性对共性的属性和方法的接收，一般都会再加入个性独有的属性和方法。一个类继承另一个类，被继承的类为父类，继承的类为子类。继承的目的是为了实现代码的复用。父类的私有属性和构造方法不能被继承，子类可以写自己独有的属性和方法，目的是实现功能的扩展，子类也可以重写父类的方法。比如dog类继承animal类，那么dog类就是子类，animal就是父类，dog可以接收父类提供的属性和方法，比如吃东西和四条腿。也可以实现自己的方法，比如汪汪叫。")])]),t._v(" "),_("h3",{attrs:{id:"_1-3-多态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-多态"}},[t._v("#")]),t._v(" 1.3.多态")]),t._v(" "),_("blockquote",[_("p",[t._v("多态是以封装和继承为基础的，就是在抽象的层面上实施一个统一的行为，这个统一的行为会因为个体的形态特征而实施自己的特征行为。就是相同的事物，调用相同的方法，参数也相同但是表现的行为缺完全不同。子类以父类的身份出现，但是做的事情还是自己的方法实现，子类以父类身份出现的时候需要向上转型，这个是由jvm自动实现的，是安全的。但是向下转型是不安全的，需要强制类型转换。子类以父类的身份出现时自己特有的属性和方法将不能使用。")])]),t._v(" "),_("h2",{attrs:{id:"_2-数据类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-数据类型"}},[t._v("#")]),t._v(" 2.数据类型")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://xcu-oss.oss-cn-beijing.aliyuncs.com/img/333.png",alt:"333"}})]),t._v(" "),_("p",[t._v("基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间，必须通过实例化开辟数据空间之后才可以赋值。数组对象也是一个引用对象，将一个数组赋值给另一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看的见。")]),t._v(" "),_("h2",{attrs:{id:"_3-请介绍一下访问修饰符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-请介绍一下访问修饰符"}},[t._v("#")]),t._v(" 3.请介绍一下访问修饰符")]),t._v(" "),_("p",[t._v("Java除了提供的三个访问修饰符分别代表三个访问级别之外还有一个不加修饰符的访问级别,它们访问级别控制从小到大为： "),_("code",[t._v("private")]),t._v("->"),_("code",[t._v("default")]),t._v("->"),_("code",[t._v("protected")]),t._v("->"),_("code",[t._v("public")])]),t._v(" "),_("p",[t._v("他们访问级别分别如下：")]),t._v(" "),_("ul",[_("li",[_("code",[t._v("private")]),t._v("：类中被private修饰的成员只能在当前类的内部被访问。根据这点,我们可以使用它来修饰成员变量,从而将成员变量隐藏在这个类的内部。")]),t._v(" "),_("li",[_("code",[t._v("default")]),t._v("：如果类中的成员或者一个外部类不使用任何访问修饰符来进行修饰,那么他就是default级别的,default访问控制的类成员或者外部类可以被相同包下的其他类访问。")]),t._v(" "),_("li",[_("code",[t._v("protected")]),t._v("：如果一个类成员被protected访问修饰符修饰,那么这个成员不但可以被同一个包下的其他类访问,还可以被其他包下的子类访问。一般来讲,如果一个方法被protected修饰,那么通常是希望它的子类来重写它。")]),t._v(" "),_("li",[_("code",[t._v("public")]),t._v("：这是Java中最宽松的访问级别,如果类成员被这个修饰符修饰,那么无论访问类和被访问类在不在一个包下,有没有父子关系,这个类成员都可以被访问到。")])]),t._v(" "),_("p",[t._v("对于局部变量而言,它的作用域就是他所在的方法,不可能被其它类所访问,所以不能使用访问修饰符来修饰。")]),t._v(" "),_("p",[t._v("对于外部类而言,它只有两种控制级别：public和默认,外部类之所以不能用protected和private修饰,是因为外部类没有处于任何类的内部,所以就没有它所在类的内部,所在类的子类两个范围,protected和private没有意义。")]),t._v(" "),_("p",[t._v("使用public声明的外部类可以被所有类引用；不使用访问修饰符创建的外部类只有同一个包内的类能引用。")])])}),[],!1,null,null,null);_.default=e.exports}}]);