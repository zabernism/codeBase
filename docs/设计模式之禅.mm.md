
# 设计模式之禅
## 第一部分 大旗不挥，谁敢冲锋——6大设计原则全新解读
### 第1章 单一职责原则
#### 1.1 我是“牛”类，我可以担任多职吗
> 单一职责原则的英文名称是Single Responsibility Principle，简称是SRP。定义:应该有且仅有一个原因引起类的变更；例如我们要设计一个基于RBAC的权限模型，在设计用户实体类的同时虽然可以将他的属性和执行的
#### 1.2 绝杀技，打破你的传统思维
- SRP的原话是：There should never be more than one reason for a class to change（一个类改变的原因不应该超过一个）。例如一个手机的接口IPhone，里边设计三个方法：拨号、通话、挂断。我们惯性思维觉得这样设计没有问题，但是他其实是违背单一职责的，单一职责讲的是：一个类只负责一件事。而这个IPhone接口既包含协议管理(接通和挂机)，又包含数据传输(通话)
- 我们可以将上述一个接口IPhone拆解成两个接口，一个负责协议、一个负责传输
- 单一职责的好处:
    - 累的复杂性降低，实现什么职责都有明确的定义
    - 可读性提高，复杂性降低，那当然是可读性提高了
    - 可维护性提高，可读性提高了，那当然是更好维护了
    - 变更引起的风险降低，变更是必不可少的，如果一个接口的单一职责做的好，一个接口修改只对相应的实现类有影响，对其他接口无影响，这对系统的扩展性、维护性都有很大的帮助
- 单一职责的难点:
    - 职责划分，这个职责没有一个具体的量化标准，一个类到底要负责那些职责，这些职责该如何细化，细化后是否都要有一个接口或类。
    - 项目要考虑可变不可变因素以及相关的收益成本比率，从功能上来说，定义一个IPhone接口也没有错，实现了电话的功能，而且设计还简单。
- 注意
    - 单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类的设计是否优良，但是“职责”和“变化原因”都是不可度量的，因项目而异，因环境而异
#### 1.3. 我单纯，所以我快乐
- 对于接口，我们在设计的时候要尽量做到单一，但是对于实现类就需要多方面考虑了。生搬硬套单一职责原则会引起类的剧增，给维护带来非常多的麻烦，而且过分细分类的职责也会人为地增加系统的复杂性。本来一个类可以实现的行为硬要拆成两个类，然后再使用聚合或组合的方式耦合在一起，人为制造了系统的复杂性。所以原则是死的，人是活的，这句话很有道理。
- 单一职责适用于接口、类，同时也适用于方法，什么意思呢？一个方法尽可能做一件事情，比如一个方法修改用户密码，不要把这个方法放到“修改用户信息”方法中，这个方法的颗粒度很粗
### 第2章 里氏替换原则
#### 2.1 爱恨纠葛的父子关系
- 继承的优缺点
    - 优点
        - 代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性
        - 提高代码的重用性
        - 子类可以形似父类，又异于父类“龙生龙，凤生凤，老鼠生来会打洞”是说子拥有父的“种”，“世界上没有两片完全相同的叶子”是指明子与父的不同；
        - 提高代码的可扩展性，实现父类的方法就可以“为所欲为”了，君不见很多开源框架的扩展接口都是通过继承父类来完成的；
        - 提高产品或项目的开放性。
    - 缺点
        - 继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法；
        - 降低代码的灵活性。子类必须拥有父类的属性和方法，让子类自由的世界中多了些约束；
        - 增强了耦合性。当父类的常量、变量和方法被修改时，需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大段的代码需要重构。
- 里氏替换原则(Liskov Substitution Principle，LSP)定义：
    - 第一种定义，也是最正宗的定义：If for each object o1 of type S there is an object o2 of
    type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is
    substituted for o2 then S is a subtype of T.（如果对每一个类型为S的对象o1，都有类型为T的对
    象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变
    化，那么类型S是类型T的子类型。）
    - Functions that use pointers or references to base classes must be able to use
    objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的
    对象。）
    - 第二个定义是最清晰明确的，通俗的讲，只要父类能出现的地方，子类就可以出现，而且替换为子类也不会产生任何错误或者异常。
#### 2.2 纠纷不断，规则压制
- 里氏替换原则的定义包含四层定义
    - 1.子类必须完全实现父类的方法
        - 如果子类不能完整的实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系替代
    - 2.子类可以有自己的个性
        - 子类可以拥有自己的个性和外观，子类出现的地方，父类未必就可以胜任
        - 向下转型是不安全的，容易抛出`ClassCaseException`异常
    - 3.覆盖或实现父类的方法时输入参数可以被放大
        - ```
            public class Main {
                public static void main(String[] args) {
                    // 父类能够存在的地方，子类就可以存在----里氏替换原则
                    Son f = new Son();
                    HashMap map = new HashMap();
                    f.doSomething(map); // 父类方法被执行
                }
            }
          
            class Father {
                public void doSomething(HashMap mp) {
                    System.out.println("父类方法被执行");
                }
            }
          
            class Son extends Father {
                public void doSomething(Map mp) {
                    System.out.println("子类方法被执行");
                }
            }   
          ```
            - 上述代码中，可以看到子类继承父类，并且重载了父类的doSomething方法(注意不是重写，重写要求子类方法名与参数完全与父类一致，重载要求子类与父类方法名一致而参数类型不同)；父类的方法名是HashMap而子类的方法名参数为Map，，也就是说子类的输入参数类型的范围扩大了，子类代替父类传递到调用者中，子类的方法永远都不会被执行(除非将参数换为Map),这是正确的
        - ```
            // 如果将上述代码进行调整，父类的前置条件大于子类的情况
            public class Main {
                public static void main(String[] args) {
                    // 父类能够存在的地方，子类就可以存在----里氏替换原则
                    Son f = new Son();
                    HashMap map = new HashMap();
                    f.doSomething(map); // 子类方法被执行
                }
            }
            
            class Father {
                public void doSomething(Map mp) {
                    System.out.println("父类方法被执行");
                }
            }
            
            class Son extends Father {
                public void doSomething(HashMap mp) {
                    System.out.println("子类方法被执行");
                }
            }
            ```
            - 子类方法并没有重写父类方法，但是仍然被执行了，这会引起业务逻辑混乱，因为在实际应用中父类一般都是抽象类，子类是实现类，你传递一个这样的实现类就会“歪曲”了父类的意图，引起一堆意想不到的业务逻辑混乱，所以子类中方法的前置条件必须与超类中被覆写的方法的前置条件相同或者更宽松。
    4. 重写或实现父类的方法时输出结果可以被缩小
        - 父类的一个方法的返回值是一个类型T，子类的相同方法（重载或重写）的返回值为S，那么里氏替换原则就要求S必须小于等于T，也就是说，要么S和T是同一个类型，要么S是T的子类，分两种情况：
            - 如果是重写，父类和子类的同名方法的输入参数是相同的，两个方法的范围值S小于等于T，这是覆写的要求，这才是重中之重，子类覆写父类的方法，天经地义。
            - 如果是重载，则要求方法的输入参数类型或数量不相同，在里氏替换原则要求下，就是子类的输入参数宽于或等于父类的输入参数，也就是说你写的这个方法是不会被调用的，参考上面讲的前置条件。
        - 采用里氏替换原则的目的就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。在实际项目中，每个子类对应不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑，非常完美

### 第3章 依赖倒置原则
#### 3.1 依赖倒置原则的定义
- 依赖倒置原则（Dependence Inversion Principle,DIP）
    - 高层模块不应该依赖低层模块，两者都应该依赖其抽象；
    - 抽象不应该依赖细节；
    - 细节应该依赖抽象。
- 他在JAVA中的表现就是
    - 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；
    - 接口或抽象类不依赖于实现类；
    - 实现类依赖接口或抽象类。
#### 3.2 言而无信，你太需要契约
- 采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。
#### 3.3 依赖的三种写法
- 依赖是可以传递的，只要做到抽象依赖，即使是多层的依赖传递也无所畏惧
- 1.构造函数传递依赖对象
    - ```
        public interface IDriver {
            /**
            * 驾车
            */
            void drive();
        }
      
        class Driver implements IDriver {
      
            private ICar car;
      
            private Driver(ICar car) {
                this.car = car;
            }
      
            @Override
            public void drive() {
                car.run();
            }       
        }
      
        interface ICar {
      
        /**
        * 汽车启动
        */
        void run();
        }
      ```
- 2.Setter方法传递依赖对象
    - ```
       class Driver implements IDriver {
      
            private ICar car;
      
            public void setCar(ICar car) {
                this.car = car;
            }
      
            @Override
            public void drive() {
                car.run();
            }
        }
      ```
- 3.接口声明依赖对象
    - ```
        public interface IDriver {
            /**
            * 驾车
            */
            void drive(ICar car);
        }
      
        interface ICar {
      
            /**
            * 汽车启动
            */
            void run();
        }
      
        class Car implements ICar {
      
            @Override
            public void run() {
                System.out.println("汽车启动");
            }
        }
      
        class Driver implements IDriver {
      
            @Override
            public void drive(ICar car) {
                System.out.println("司机驾驶");
                car.run();
            }
        }
      
        class Main {
            public static void main(String[] args) {
                IDriver driver = new Driver();
                driver.drive(new Car());
            }
        }
      ```
#### 3.4 注意事项
- 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备(接口和抽象类都是属于抽象的，有了抽象才可能依赖倒置)
- 变量的表面类型尽量是接口或者是抽象类
- 任何类都不应该从具体类派生(如果一个项目处于开发状态，确实不应该有从具体类派生出子类的情况，但这也不是绝对的，因为人都是会犯错误的，有时设计缺陷是在所难免的，因此只要不超过两层的继承都是可以忍受的。特别是负责项目维护的同志，基本上可以不考虑这个规则，为什么？维护工作基本上都是进行扩展开发，修复行为，通过一个继承关系，覆写一个方法就可以修正一个很大的Bug，何必去继承最高的基类呢？)
- 尽量不要覆写基类的方法(如果基类是一个抽象类，而且这个方法已经实现了，子类尽量不要覆写。类间依赖的是抽象，覆写了抽象方法，对依赖的稳定性会产生一定的影响)
-  接口负责定义public属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化。
### 第4章 接口隔离原则
#### 4.1 接口隔离原则的定义
- 客户端不应该依赖它不需要的接口
- 类间的依赖关系应该建立在最小的接口上
### 第5章 迪米特法则
### 第6章 开闭原则
## 第二部分 真刀实枪——23种设计模式完美演绎
## 第三部分 谁的地盘谁做主——设计模式PK
## 第四部分 完美世界——设计模式混编
## 第五部分 扩展篇
