
# 设计模式之禅
## 第一部分 大旗不挥，谁敢冲锋——6大设计原则全新解读
### 第1章 单一职责原则
#### 1.1 我是“牛”类，我可以担任多职吗
> 单一职责原则的英文名称是Single Responsibility Principle，简称是SRP。定义:应该有且仅有一个原因引起类的变更；例如我们要设计一个基于RBAC的权限模型，在设计用户实体类的同时虽然可以将他的属性和执行的
#### 1.2 绝杀技，打破你的传统思维
- SRP的原话是：There should never be more than one reason for a class to change（一个类改变的原因不应该超过一个）。例如一个手机的接口IPhone，里边设计三个方法：拨号、通话、挂断。我们惯性思维觉得这样设计没有问题，但是他其实是违背单一职责的，单一职责讲的是：一个类只负责一件事。而这个IPhone接口既包含协议管理(接通和挂机)，又包含数据传输(通话)
- 我们可以将上述一个接口IPhone拆解成两个接口，一个负责协议、一个负责传输
- 单一职责的好处:
    - 累的复杂性降低，实现什么职责都有明确的定义
    - 可读性提高，复杂性降低，那当然是可读性提高了
    - 可维护性提高，可读性提高了，那当然是更好维护了
    - 变更引起的风险降低，变更是必不可少的，如果一个接口的单一职责做的好，一个接口修改只对相应的实现类有影响，对其他接口无影响，这对系统的扩展性、维护性都有很大的帮助
- 单一职责的难点:
    - 职责划分，这个职责没有一个具体的量化标准，一个类到底要负责那些职责，这些职责该如何细化，细化后是否都要有一个接口或类。
    - 项目要考虑可变不可变因素以及相关的收益成本比率，从功能上来说，定义一个IPhone接口也没有错，实现了电话的功能，而且设计还简单。
- 注意
    - 单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类的设计是否优良，但是“职责”和“变化原因”都是不可度量的，因项目而异，因环境而异
#### 1.3. 我单纯，所以我快乐
- 对于接口，我们在设计的时候要尽量做到单一，但是对于实现类就需要多方面考虑了。生搬硬套单一职责原则会引起类的剧增，给维护带来非常多的麻烦，而且过分细分类的职责也会人为地增加系统的复杂性。本来一个类可以实现的行为硬要拆成两个类，然后再使用聚合或组合的方式耦合在一起，人为制造了系统的复杂性。所以原则是死的，人是活的，这句话很有道理。
- 单一职责适用于接口、类，同时也适用于方法，什么意思呢？一个方法尽可能做一件事情，比如一个方法修改用户密码，不要把这个方法放到“修改用户信息”方法中，这个方法的颗粒度很粗
### 第2章 里氏替换原则
#### 2.1 爱恨纠葛的父子关系
- 继承的优缺点
    - 优点
        - 代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性
        - 提高代码的重用性
        - 子类可以形似父类，又异于父类“龙生龙，凤生凤，老鼠生来会打洞”是说子拥有父的“种”，“世界上没有两片完全相同的叶子”是指明子与父的不同；
        - 提高代码的可扩展性，实现父类的方法就可以“为所欲为”了，君不见很多开源框架的扩展接口都是通过继承父类来完成的；
        - 提高产品或项目的开放性。
    - 缺点
        - 继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法；
        - 降低代码的灵活性。子类必须拥有父类的属性和方法，让子类自由的世界中多了些约束；
        - 增强了耦合性。当父类的常量、变量和方法被修改时，需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大段的代码需要重构。
- 里氏替换原则(Liskov Substitution Principle，LSP)定义：
    - 第一种定义，也是最正宗的定义：If for each object o1 of type S there is an object o2 of
type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is
substituted for o2 then S is a subtype of T.（如果对每一个类型为S的对象o1，都有类型为T的对
象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变
化，那么类型S是类型T的子类型。）
    - Functions that use pointers or references to base classes must be able to use
objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的
对象。）
    - 第二个定义是最清晰明确的，通俗的讲，只要父类能出现的地方，子类就可以出现，而且替换为子类也不会产生任何错误或者异常。
        -    ```java
                public abstract class AbstractGun {
                //枪用来干什么的？杀敌！
                public abstract void shoot();
            }
            ```
#### 2.2 纠纷不断，规则压制
- 里氏替换原则的定义包含四层定义
    - 1.子类必须完全实现父类的方法

### 第3章 依赖倒置原则
### 第4章 接口隔离原则
### 第5章 迪米特法则
### 第6章 开闭原则
## 第二部分 真刀实枪——23种设计模式完美演绎
## 第三部分 谁的地盘谁做主——设计模式PK
## 第四部分 完美世界——设计模式混编
## 第五部分 扩展篇
